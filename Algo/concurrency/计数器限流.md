假如系统能同时处理 $100$ request / sec，保存一个计数器，处理了一个请求，计数器加一，一个请求处理完毕之后计数器减一。每次请求来的时候看看计数器的值，如果超过阈值要么拒绝。

![[Pasted image 20210909141740.png]]

```c

int counter;
const int threshold;

bool try_acquire() {
	if (counter < threshold) {
		++counter;
		return true;
	}
	return false;
}

bool try_release() {
	if (counter > 0) {
		--counter;
		return true;
	}
	return false;
}

```

# 计数器固定窗口算法

通过维护一个单位时间内的计数值，每当一个请求通过时，就将计数值加1，当计数值超过预先设定的阈值时，就拒绝单位时间内的其他请求。如果单位时间已经结束，则将计数器清零，开启下一轮的计数。

## 临界问题

假设系统每秒允许 100 个请求，假设第一个时间窗口是 0-1s，在第 0.55s 处一下次涌入 100 个请求，过了 1 秒的时间窗口后计数清零，此时在 1.05 s 的时候又一下次涌入100个请求。

虽然窗口内的计数没超过阈值，但是全局来看在 0.55s-1.05s 这 0.1 秒内涌入了 200 个请求，这其实对于阈值是 100/s 的系统来说是无法接受的。

![[Pasted image 20210909171932.png]]

# 计数器滑动窗口算法

![[Pasted image 20210909172751.png]]

假设时间窗口为 1 秒：

-   记录每次请求的时间
-   统计每次请求的时间 至 往前推1秒这个时间窗口内请求数，并且 1 秒前的数据可以删除。
-   统计的请求数小于阈值就记录这个请求的时间，并允许通过，反之拒绝。



滑动窗口和固定窗口都**无法解决短时间之内集中流量的突击**。

我们所想的限流场景，例如每秒限制 100 个请求。希望请求每 10ms 来一个，这样我们的流量处理就很平滑，但是真实场景很难控制请求的频率。因此可能存在 5ms 内就打满了阈值的情况。

[[leak bucket]]可以解决时间窗口类的痛点，使得流量更加的平滑。