# Language

- 等号左边表示存储位置，称为左值 （lvalue）。等号右边表示要存储的值，可以是任意组合的表达式，所以通常所说的表达式的值 也称为右值（rvalue）
- C语言定义的取整运算既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截断 （Truncate），所以当操作数为正的时候相当于Floor，当操作符为负的时候相当于Ceiling。

使用math.h中的函数还有一点特殊之处，gcc命令行必须加`-lm`选项，因为数学函数位 于`libm.so`库文件中（通常在`/lib`目录下），`-lm`选项告诉编译器，我们程序中用到的数学函数 要到这个库文件里找。本书用到的大部分库函数（例如printf）位于`libc.so`库文件中，以后称 为`libc`，使用`libc`中的库函数在编译时不需要加`-lc`选项，当然加了也不算错，因为这个选项 是gcc默认的。

由于有Old Style C语法的存在，并不是所有函数声明都包含函数原型，例如声明`void threeline();`没有明确指出参数类型和个数，所以不算函数原型，这个声明提供给编译器的信息 只有函数名和返回值类型。如果在这样的声明之后调用函数，编译器将不做参数类型检查和自 动转换，所以很容易引入Bug。

函数的**隐式声明（Implicit Declaration）**，在main函数中调用threeline时并没有声明它，则编译器认为此处隐式声明 了int threeline(void);，然后为这个调用生成相应的指令，**隐式声明的参数类型和个数根据函 数调用代码来确定，隐式声明的返回值类型总是int**。然后编译器接着往下看，看 到threeline函数的原型是void threeline(void)，和先前的隐式声明的返回值类型不符，所以 才报这个警告。

`int printf(const char *format, ...);`

**在函数体中，通常把所有的变量定义语句放在最前面，然后才是其它语句，这是传统C的规定**，我们之 前举的所有例子都遵守这一规定。C99允许变量定义穿插在其它语句之中，只要对于每个变量都 遵循先定义后使用的原则就可以，不管怎么样，使用传统C的特性总是比较保险的。

**局部变量可以用任意类型相符的表达式来初始化，而全局变量只 能用常量表达式初始化（use macro）** 全局变量的初始值要求保存在编译生成的目标代码中， 所以必须在编译时就能计算出来。

**和函数的局部变量同样道理，每次进入语句块时为变量`j`分配存储空间，每次退出语句块时释放 变量`j`的存储空间。**
