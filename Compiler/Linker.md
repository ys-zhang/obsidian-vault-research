#linker 

1. [A great blog series about linker](https://www.airs.com/blog/archives/38)
2. [PLT and GOT - the key to code sharing and dynamic libraries](https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html)

The following are some key points and take aways from the first blog.


# Introduction: The History

When languages liked Fortran and Cobol started to appear, people began to _think in terms of libraries of subroutines_, which meant that there had to be some way to _run the assembler at two different times_, and _combine the output into a single executable file_.

This required the assembler to generate a different type of output, which became known as an **object file** . 

And a new program was required to combine different object files together into a single executable. This new program became known as the **linker**.

Linkers still do the same job today. In the decades that followed, one new feature has been added: **shared libraries**.

## Shared Libraries

Shared libraries were invented as an optimisation for _virtual memory systems_ running many processes simultaneously. 

People noticed that there is a set of basic functions which _appear in almost every program_. Before **shared libraries**, in a system which runs multiple processes simultaneously, that meant that almost every process had a copy of exactly the same code. This suggested that on a virtual memory system it would be possible to _arrange that code so that a single copy could be shared by every process using it_. The virtual memory system would be used to map the single copy into the address space of each process which needed it. This would require less physical memory to run multiple programs, and thus yield better performance.

Implementations of _shared library_ in terms of _virtual memory_:
1. assigned each shared library a fixed portion of the virtual address space.
2. postponed some of the operation of the _linker_ to runtime. The version of the linker which runs when the program starts is known as the __dynamic linker__.

The **program linker** now had to build _linking information_ which could be used efficiently at runtime by the **dynamic linker**.

# Basic Linker Data Types

The linker operates on a small number of basic data types: _symbols_, _relocations_, and _contents_, which are defined in the input **object files**.


## Symbol

> A **symbol** is basically a _name_ and a _value_.

> During the linking process, the linker will **assign** an address to each _defined symbol_, and will __resolve__ each _undefined symbol_ by finding a _defined symbol_ with the same name.

- __Defined symbol__:

  In an object file generated from C code, there will be a symbol for each function and for each global and static variable. The value of such a symbol is simply an offset into the contents.   It’s important not to confuse the value of the symbol representing the variable `my_global_var` with the value of `my_global_var` itself. The value of the symbol is roughly the address of the variable: the value you would get from the expression `&my_global_var` in C.

- **Undefined symbol**

  indicate a _reference_ to a name defined in a _different_ object file.

## Content and Relocation

The **contents** are what memory should look like during the execution of the program. 

**Contents** have 
- a **size**,
- an array of **bytes**
- and a **type**.

**Contents** contain 
1. the _machine code_ generated by the compiler and assembler (known as `text`).
2. the _values_ of _initialised variables_ (`data`).
3. _static unnamed data_ like string constants and switch tables (read-only data or `rdata`)
4. _uninitialised variables_, in which case the array of bytes is generally omitted and assumed to contain only zeroes (`bss`)

A **relocation** is a computation to perform on the **contents**.

A simple, and commonly used, **relocation** is _“set this location in the **contents** to the **value** of this **symbol** plus this **addend**.”_

The types of computations that relocations do are inherently dependent on the architecture of the processor for which the linker is generating code.

During the linking process, the linker will perform all of the relocation computations as directed. A relocation in an object file may refer to an undefined symbol. If the linker is unable to resolve that symbol, it will normally issue an error (but not always: for some symbol types or some relocation types an error may not be appropriate).

The compiler and the assembler work hard to generate exactly the right contents, but the linker really doesn’t care about them except as raw data. The linker reads the contents from each file, concatenates them all together sorted by type, applies the relocations, and writes the result into the executable file.

# Basic Linker Operation

-   Read the input _object files_. Determine the length and type of the contents. Read the symbols.
-   Build a _symbol table_ containing all the symbols, linking undefined symbols to their definitions.
-   Decide where all the contents should go in the output executable file, which means deciding where they should go in memory when the program runs.
-   Read the contents data and the relocations. Apply the relocations to the contents. Write the result to the output file.
-   Optionally write out the complete symbol table with the final values of the symbols.

## Address Spaces

The linker deals with 3 distinct types of _address space_.

1. Every input _object file_ is a small address space: the contents have addresses, and the symbols and relocations refer to the contents by addresses.
2. The output program will be placed at some location in memory when it runs. This is the *output address space*, which I generally refer to as using __virtual memory addresses__.
3. The output program will be loaded at some location in memory. This is the __load memory address__. On typical Unix systems virtual memory addresses and load memory addresses are the same. On embedded systems they are often different; for example, the initialised data (the initial contents of global or static variables) may be loaded into ROM at the load memory address, and then copied into RAM at the virtual memory address.


## Object File Formats

An _assembler_ turns human readable assembly language into an _object file_. 
An object file is a binary data file written in a format _designed as input to the linker_.

```
  asm file
     |
     |
     v
+---------+
|assembler| 
+---------+
     |
     |
     v
 object file
     |
     |
     v
 +------+
 |linker|
 +------+
     |
     |
     v
executable file
     |
     |
     v
+--------+
| loader |
+--------+
```

Most _object file_ formats define _sections_. A section typically holds _memory contents_, or it may be used to hold other types of data. _Sections_ generally have a name, a type, a size, an address, and an associated array of data.

Object file formats may be classed in two general types: 

1. _record oriented_ 

    A record oriented object file format defines a series of records of varying size. Each record starts with some special code, and may be followed by data. Reading the object file requires reading it from the beginning and processing each record. _Records are used to describe symbols and sections._ _Relocations may be associated with sections or may be specified by other records._ IEEE-695 and Mach-O are record oriented object file formats used today.
2. _section oriented_.

    In a section oriented object file format the file header describes a section table with a specified number of sections. _Symbols may appear in a separate part of the object file described by the file header, or they may appear in a special section._ _Relocations may be attached to sections, or they may appear in separate sections._ The object file may be read by reading the section table, and then reading specific sections directly. [[ELF (Executable and Linkable Format)]], COFF, PE, and a.out are section oriented object file formats.

>[!NOTE] Debug Info
> Every object file format needs to be able to represent debugging information.
> 
> The `a.out` _object file format_ stores debugging information using special strings in the _symbol table_, known as **stabs**.
> 
> The linker can use various techniques to reduce the amount of debugging information, thus reducing the size of the executable. This can speed up the link, but requires the linker to understand the debugging information.


## Shared Library

Shared libraries can normally be run at different virtual memory address in different processes. 

A shared library has a _base address_ when it is created; this is often simply $0$. 

When the _dynamic linker_ copies the _shared library_ into the _virtual memory space_ of a process, it must apply _relocations_ to adjust the shared library to run at its virtual memory address. 

Shared library systems minimise the number of relocations which must be applied, since they take time when starting the program.

### DLL (Windows Shared Libraries)

### ELF 

When the program linker creates a shared library, it does not yet know which virtual address that shared library will run at. In fact, in different processes, the same shared library will run at different address, depending on the decisions made by the dynamic linker.

This means that shared library code must be __position independent__. More precisely, it must be position independent after the dynamic linker has finished loading it. It is always possible for the dynamic linker to convert any piece of code to run at any virtual address, given sufficient relocation information. However, performing the relocation computations must be done every time the program starts, implying that it will start more slowly. Therefore, any shared library system seeks to generate _position independent code_ which _requires a minimal number of relocations_ to be applied at runtime, while still running at close to the runtime efficiency of position dependent code.

An additional complexity is that ELF shared libraries were designed to be roughly equivalent to ordinary archives. This means that _by default the main executable may override symbols in the shared library_, _such that references in the shared library will call the definition in the executable, even if the shared library also defines that same symbol_. For example, an executable may define its own version of `malloc`. 

### PIC, PLT & GOT

In the common case, code may be compiled in two different modes. By default, code is _position dependent_. Putting position dependent code into a shared library will cause the program linker to generate a lot of relocation information, and cause the dynamic linker to do a lot of processing at runtime. _Position independent code is slightly slower when it calls a non-static function or refers to a global or static variable._ However, it requires much less relocation information, and thus the dynamic linker will start the program faster.

> Position independent code will call **non-static** functions via the __Procedure Linkage Table__ or __PLT__. 

This _PLT_ does not exist in `.o` files. In a `.o` file, use of the _PLT_ is indicated by a _special relocation_. 

When the _program linker_(not the dynamic linker) processes such a relocation, it will create an entry in the _PLT_. It will adjust the instruction such that it becomes a _PC-relative call to the PLT entry_. PC-relative calls are inherently position independent and thus do not require a relocation entry themselves. The _program linker_ will create a relocation for the PLT entry which tells the dynamic linker which symbol is associated with that entry. This process reduces the number of dynamic relocations in the shared library from one per function call to one per function called.

> Further, PLT entries are normally **relocated lazily** by the dynamic linker.

On most ELF systems this laziness may be overridden by setting the `LD_BIND_NOW` environment variable when running the program.

By default, the program linker initialises the _PLT entries_ to load an index into some register or push it on the stack, and then to branch to common code. The common code calls back into the _dynamic linker_, which _uses the index to find the appropriate PLT relocation_, and uses that to find the function being called. The _dynamic linker_ then initialises the _PLT entry_ with the address of the function, and then jumps to the code of the function. The next time the function is called, the _PLT entry_ will branch directly to the function.

> The __Global Offset Table__ or __GOT__. This is used for _global_ and _static_ variables.

For every reference to a global variable from _position independent code_, the compiler will generate a load from the _GOT_ to get the address of the variable, followed by a second load to get the actual value of the variable. The address of the _GOT_ will normally be held in a register, permitting efficient access. 

Like the _PLT_, the _GOT_ does not exist in a `.o` file, but is created by the program linker. The program linker will create the dynamic relocations which the dynamic linker will use to initialise the _GOT_ at runtime. 

Unlike the _PLT_, the dynamic linker always fully initialises the _GOT_ when the program starts. On the i386, the address of the _GOT_ is held in the register `%ebx`.

Global and static variables are now read or written by first loading the address via a _fixed offset from_ `%ebx`. The program linker will create dynamic relocations for each entry in the GOT, telling the dynamic linker how to initialise the entry. These relocations are of type `GLOB_DAT`.

The program linker will allocate an entry in the _GOT_ for each entry in the _PLT_. It will create a dynamic relocation for the _GOT_ entry of type `JMP_SLOT`. It will initialise the _GOT_ entry to the base address of the shared library plus the address of the second instruction in the code sequence above. When the _dynamic linker_ does the initial lazy binding on a `JMP_SLOT` reloc, it will simply add the difference between the shared library load address and the shared library base address to the GOT entry. The effect is that the first `jmp` instruction will jump to the second instruction, which will push the index entry and branch to the first PLT entry.

For _position independent code_ on the i386, every call to a global function requires one extra instruction after the first time it is called. Every reference to a global or static variable requires one extra instruction. Almost every function uses four extra instructions when it starts to initialize `%ebx` (leaf functions which do not refer to any global variables do not need to initialize %ebx). This all has some negative impact on the program cache. This is the runtime performance penalty paid to let the dynamic linker start the program quickly.

